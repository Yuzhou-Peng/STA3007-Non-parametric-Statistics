---
title: "STA3007_hw9_codes"
author: "Yuzhou Peng"
date: "2025-04-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load required libraries and data
library(MASS)
data(Boston)
library(np)       # For kernel regression
library(splines)  # For regression splines

motor <- read.table("C:\\Users\\Penguin\\Desktop\\STA3007\\motor.dat")


```

#Q11
```{r}
colnames(motor) <- motor[1,]
motor <- motor[-1,]
X = as.numeric(motor$time)
Y = as.numeric(motor$accel)
```

```{r}
loocv_cubic_spline <- function(k) {
  n <- length(X)
  errors <- numeric(n)
  
  for (i in 1:n) {
    x_train <- X[-i]
    y_train <- Y[-i]

    knots <- seq(min(x_train), max(x_train), length.out = k + 2)[-c(1, k + 2)]
    model <- lm(y_train ~ bs(x_train, knots = knots, degree = 3, Boundary.knots = c(min(x_train), max(x_train))))
    x_test <- X[i]
    y_pred <- predict(model, newdata = data.frame(x_train = x_test))
    errors[i] <- (Y[i] - y_pred)^2
  }
  mean(errors) 
}

```

```{r}
k_values <- 5:20
cv_errors <- sapply(k_values, loocv_cubic_spline)

best_k <- k_values[which.min(cv_errors)]
```

```{r}
best_knots <- quantile(X, probs = seq(0, 1, length.out = best_k + 2))[-c(1, best_k + 2)]
fit_spline <- lm(Y ~ bs(X, knots = best_knots, degree = 3, intercept = TRUE))
fit_smooth <- smooth.spline(X, Y, cv = TRUE)

summary(fit_spline)
summary(fit_smooth)

pred_spline <- predict(fit_spline, x = X)
pred_smooth <- predict(fit_spline, x = X)

plot(X, Y, pch = 16, col = "black", xlab = "Time (ms)", ylab = "Acceleration (g)",
     main = "Cubic Regression Spline vs. Smoothing Spline")

lines(X, pred_smooth, col = "green", lwd = 2)
lines(X, pred_spline, col = "blue", lwd = 2, lty = 3)

legend("topright", legend = c("Smoothing Spline", "Regression Spline"),
       col = c("green", "blue"), lty = c(1, 3), lwd = 2)
```


#Boston Housing
```{r}
# Function to estimate sigma^2 using smoothing matrix S
estimate_sigma2 <- function(y, S) {
  y_hat <- S %*% y
  RSS <- sum((y - y_hat)^2)
  tr_S <- sum(diag(S))
  n <- length(y)
  sigma2 <- RSS / (n - tr_S)
  return(sigma2)
}

# Extract predictor and response
x <- Boston$rm
y <- Boston$medv
n <- nrow(Boston)
```

```{r}
# 1. Nadaraya-Watson Kernel Regression
bw_nw <- npregbw(formula = y ~ x, regtype = "lc", bwmethod = "cv.aic")
h_nw <- bw_nw$bw
Epanechnikov <- function(u) 0.75 * (1 - u^2) * (abs(u) <= 1)
S_nw <- matrix(0, n, n)
for (i in 1:n) {
  u <- (x - x[i]) / h_nw
  K <- Epanechnikov(u)
  S_nw[i, ] <- K / sum(K)
}
sigma2_nw <- estimate_sigma2(y, S_nw)

S_nw
sigma2_nw
```

```{r}
# 2. Local Linear Regression
bw_ll <- npregbw(formula = y ~ x, regtype = "ll", bwmethod = "cv.aic")
h_ll <- bw_ll$bw
S_ll <- matrix(0, n, n)
for (i in 1:n) {
  xi <- x[i]
  u <- (x - xi) / h_ll
  K <- Epanechnikov(u)
  valid <- K > 0
  X <- cbind(1, x[valid] - xi)
  W <- diag(K[valid])
  if (sum(valid) >= 2 && qr(X)$rank == 2) {
    XWX_inv <- solve(t(X) %*% W %*% X)
    M_i <- XWX_inv %*% t(X) %*% W
    S_ll[i, valid] <- M_i[1, ]
  } else {
    S_ll[i, valid] <- K[valid] / sum(K[valid])
  }
}
sigma2_ll <- estimate_sigma2(y, S_ll)

S_ll
sigma2_ll

```

```{r}
# 3. Smoothing Splines

#use cross-validation to choose best smoothing parameter
spar = seq(0.01, 1, by = 0.01)
cv = rep_len(NA, length(spar))
for(i in 1:length(spar)){
    tempfit = smooth.spline(x, y, spar = spar[i], cv=TRUE, all.knots = TRUE)
    cv[i] = tempfit$cv.crit
}

#use the optimal smoothing parameter to produce a final fit
fit = smooth.spline(x, y, spar = spar[which(cv == min(cv))], cv=TRUE, all.knots = TRUE)

#calculate the smoothing matrix
S_ss = matrix(nrow = length(x), ncol = length(x))
for(j in 1:length(x)){
    yi = rep_len(0, length(x))
    yi[j] = 1
    S_ss[,j] = predict(smooth.spline(x, yi, lambda = fit$lambda, cv=TRUE,
                                  all.knots = TRUE), x)$y
}

S_ss

estimate_sigma2(y, S_ss)
```

```{r}
# 4. Regression Splines (10 knots)
knots <- quantile(x, probs = seq(1/10, 9/10, length.out = 10))
X_bs <- bs(x, knots = knots, intercept = TRUE)
fit_rs <- lm(y ~ X_bs)

# Method 1: Direct computation using linear algebra
S_rs <- X_bs %*% solve( t(X_bs) %*% X_bs) %*% t(X_bs) 

S_rs

estimate_sigma2(y, S_rs)
```




